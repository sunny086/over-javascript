### 4.3 map() 方法

mpa() 方法将数组的每个元素传递给指定函数，并返回一个数组，包含该函数的返回值：

```js
let arr = [1, 2, 3]
let newArr = arr.map(function (x) {
  return x * x
})
console.log(newArr) //  [ 1, 4, 9 ]
```

### 4.4 filter() 方法

该方法返回的数组元素是调用的数组的一个子集。

```js
let arr = [5, 4, 3, 2, 1]
let newArr = arr.filter(function (x) {
  return x < 3
})
console.log(newArr) //  [ 2, 1]
```

### 4.5 some() 和 every() 方法

some 用法：

```js
let arr = [1, 2, 3, 4, 5]
let isTrue = arr.every(function (x) {
  return x < 10
})
console.log(isTrue) //  true
```

every 与 some 用法相同，但是 every 强调所有元素都必须满足条件，some 只要满足一个元素即可。
其内部原理都是循环数组元素，只不过 every 会循环所有元素，some 只会循环到第一个符合的元素。那么空数组这里，every 会返回 true，some 返回 false。

### 4.6 redue() 和 reduceRight() 方法

该方法使用指定函数将数组元素组合，生成新的值：

```js
let arr = [1, 2, 3, 4, 5]

// 数组元素求和
let sum = arr.reduce(function (x, y) {
  return x + y
}, 0)

// 数组元素求积
let prod = arr.reduce(function (x, y) {
  return x * y
}, 1)

// 求最大值
let max = arr.reduce(function (x, y) {
  return x > y ? x : y
})

console.log(sum) //  15
console.log(prod) //  120
console.log(max) //  5
```

注意：

- 函数的第二个参数可选，是传递给函数的初始值，默认是数组第一个元素的值
- 空数组中，不带初始值参数调用 reduce() 会导致类型错误
- 空数组调用 reduce 并指定初始值，则直接返回初始值
- 只有一个元素的数组调用 reduce 没有指定初始值，则直接返回元素
- reduceRight() 方法是从索引的高到低开始操作。

### 1.3 数组的增删排序

```javascript
push() //数组最末位添加元素
unshift() //数组最前面添加元素
pop() //删除数组最末位元素
shift() //删除数组第一个元素
reverse() //数组反转，示例 arr.reverse().join()
sort() //从小到大依次排序
slice(i, j) //从第 i 个取到第 j 个
splice(m, n) //删除数组中从第 m 个元素开始，取出 n 个组成新数组
indexOf(x, pos)
lastIndexOf(x, pos)
```

### 1.4 数组常见 API

```js
arr1 instanceof arr2 //可以判断数组 A 是否属于数组 B，结果为布尔；
Array.isArray(arr) //H5 新 API，判断是否为数组，结果为布尔。

arr.toString() //数组转字符串，每一项逗号分隔
arr.valueOf() //同上用法，但是返回数组对象本身
//案例：
let arr = [1, 2, 3]
console.log(arr.valueOf()) //[1,2,3]
console.log(arr.toString()) //1,2,3
let arr = [123, 456, 789]
console.log(arr.join('abc')) //123abc456abc789

//数组合并 concat
let arr1 = [123, 456, 789]
let arr2 = ['ab', '张三']
let arr3 = arr1.concat(arr2)
```

## 三 稀疏数组

如果数组是稀疏的，则 length 属性值大于元素的个数。

稀疏数组的三种实现方式：

- 利用 Array() 构造函数创建
- 以大于长度的索引赋值创建
- delete 操作符可以生产稀疏数组

足够稀疏的数组通常在是线上比稠密的数组更慢，但是内存利用率更高，在查找元素时，其时间复杂度与常规对象属性的查找时间一样长。

## 五 多维数组

JS 不支持真正的多维数组，一般使用数组的数组来近似描述：

```js
let arr = new Array(10)
let length = arr.length
for (let i = 0; i < arr.length; i++) {
  arr[i] = new Array(10)
}
```

## 六 类数组

JS 的数组有一些特性，常规对象没有：

- 添加元素时，自动更新 length 属性
- length 重设为较小值，会截断数组
- 从 Array.prototype 中继承了一些有用的方法
- 类属性为 Array

这些特性虽然让数组和对象有了区别，但都不是数组的本质特性。其实可以把一个拥有 length 属性的对象看做类数组，只是类数组的 length 属性不会出现随着元素增删而自动变化：

```js
// 制作一个类数组
let a = {}

for (let i = 0; i < 10; i++) {
  a[i] = i * i
}
a.length = 10
```

类数组不能直接调用 Array.prototype 上的方法，但是由于二者本质都是对象，可以通过 call() 方式调用：

```js
let a = { 0: 'a', 1: 'b', length: 3 }
Array.prototype.join(a, '+') // "a+b+c"
Array.prototype.map.call(a, function (x) {
  // ["A", "B", "C"]
  return x.toUpperCase()
})
```

注意 Firefox 浏览器将上述方法直接定义到了构造函数上，可以如此使用：

```js
let a = { 0: 'a', 1: 'b', length: 3 }
Array.join(a, '+') // "a+b+c"
Array.map.call(a, function (x) {
  // ["A", "B", "C"]
  return x.toUpperCase()
})
```

那么兼容的代码可以这样写：

```js
Array.join =
  Array.join ||
  function (a, sep) {
    return Array.prototype.join.call(a, sep)
  }

Array.map =
  Array.map ||
  function (a, f, thisArg) {
    return Array.prototype.map.call(a, f, thisArg)
  }
```

## 七 作为数组的字符串

字符串是不可变值，如果把字符串当做数组来看待时，是只读的，如 push() 这样的操作在字符串上是无效的。

## 八 语法改进 - 数组新增方法

## 8.1 数组查找

indexOf、lastIndexOf（从后向前），这些是旧版查找：

```js
let arr = [1, 3, 5]
if (arr.indexOf(2) != -1) {
  // 未找到返回 -1，还可以传入第二个参数，指定开始查找的位置（可以是负数）
  console.log('找到了')
}
```

includes 方法，返回值为布尔：

```js
let arr1 = [1, 2, 3]
arr1.inlcludes(2)

// includes 无法查找引用类型
let arr2 = [{ name: 'lisi' }, { age: 13 }]
console.log(arr2.includes({ name: 'lisi' })) // 因为传入的参数是一个新的引用对象了
```

find 与 findIndex 可以解决引用类型查找的问题：

```js
let arr2 = [{ name: 'lisi' }, { age: 13 }]
arr.find((item) => {
  // findIndex 用来查找索引
  return item.name == 'lisi'
})
```

### 8.2 数组遍历

forEach：

```js
let arr = [1, 2, 3]
arr.forEach((item, index, arr) => {})
```

iterator 迭代器：

```js
let arr = [1, 2, 3]

let keys = arr.keys() // 返回索引的可迭代对象
console.log(keys.next()) // { value: 0, done: false }
console.log(keys.next()) // { value: 1, done: false }
console.log(keys.next()) // { value: 2, done: false }

let values = arr.values() // 返回值的可迭代对象
console.log(values.next()) // { value: 1, done: false }
console.log(values.next()) // { value: 2, done: false }
console.log(values.next()) // { value: 3, done: false }
```

every 与 some：

```js
let arr = [1, 2, 3]

// 只要有一次满足，就会返回，适合对数据的统一判断，如判断所有学生成绩是否合格，有一个不合格就会返回 false
let r1 = arr.every((value, index, data) => {
  if (value == 3) {
    return false
  }
})
console.log(r1) // false

// 只有全部数据都迭代一遍，才会返回
let r2 = arr.some((value, index, data) => {
  if (value == 3) {
    return false
  }
})
console.log(r2) // false
```

### 8.3 filter 过滤

```js
let arr = [1, 2, 3]

let newArr = arr.filter((value, index, data) => {
  if (value > 1) {
    return true
  }
})
console.log(newArr) // [ 2, 3 ]
```

### 8.4 map

```js
let arr = [1, 2, 3]

let newArr = arr.map((value, index, data) => {
  if (value > 1) {
    return value
  } else {
    return value + 1
  }
})
console.log(newArr) // [2, 2, 3 ]
```

### 8.5 reduce

```js
let arr = [1, 2, 3]

arr.reduce((pre, after, index, data) => {
  console.log(pre, after)
  return 99
})
```

输出结果为：

```txt
1 2
99 3
```

也可以传递第二个参数，代表第一次循环时，prev 的取值：

```js
let arr = [1, 2, 3]

arr.reduce((pre, after, index, data) => {
  console.log(pre, after)
  return 99
}, 30)
```

输出结果：

```txt
30 1
99 2
99 3
```

### 2.6 数组打平 flatten()

ECMAScript 2019 在 Array.prototype 上增加了两个方法：flat() 和 flatMap()。这两个方法为打平数组提供了便利。如果没有这两个方法，则打平数组就要使用迭代或递归。

下面是如果没有这两个新方法要打平数组的一个示例实现：

```js
function flatten(sourceArray, flattenedArray = []) {
  for (const element of sourceArray) {
    if (Array.isArray(element)) {
      flatten(element, flattenedArray)
    } else {
      flattenedArray.push(element)
    }
  }
  return flattenedArray
}
const arr = [[0], 1, 2, [3, [4, 5]], 6]
console.log(flatten(arr))
// [0, 1, 2, 3, 4, 5, 6]
```

这个例子在很多方面像一个树形数据结构：数组中每个元素都像一个子节点，非数组元素是叶节点。因此，这个例子中的输入数组是一个高度为 2 有 7 个叶节点的树。打平这个数组本质上是对叶节点的按序遍历。

有时候如果能指定打平到第几级嵌套是很有用的。比如下面这个例子，它重写了上面的版本，允许指定要打平几级：

```js
function flatten(sourceArray, depth, flattenedArray = []) {
  for (const element of sourceArray) {
    if (Array.isArray(element) && depth > 0) {
      flatten(element, depth - 1, flattenedArray)
    } else {
      flattenedArray.push(element)
    }
  }
  return flattenedArray
}
const arr = [[0], 1, 2, [3, [4, 5]], 6]
console.log(flatten(arr, 1))
// [0, 1, 2, 3, [4, 5], 6]
```

为了解决上述问题，规范增加了 Array.prototype.flat() 方法。该方法接收 depth 参数（默认值为 1），返回一个对要打平 Array 实例的浅复制副本。下面看几个例子：

```js
const arr = [[0], 1, 2, [3, [4, 5]], 6]
console.log(arr.flat(2))
// [0, 1, 2, 3, 4, 5, 6]
console.log(arr.flat())
// [0, 1, 2, 3, [4, 5], 6]
```

因为是执行浅复制，所以包含循环引用的数组在被打平时会从源数组复制值：

```js
const arr = [[0], 1, 2, [3, [4, 5]], 6]
arr.push(arr)
console.log(arr.flat())
// [0, 1, 2, 3, 4, 5, 6, [0], 1, 2, [3, [4, 5]], 6]
```

Array.prototype.flatMap() 方法会在打平数组之前执行一次映射操作。在功能上，arr.flatMap(f) 与 arr.map(f).flat() 等价；但 arr.flatMap() 更高效，因为浏览器只需要执行一次遍历：

```js
const arr = [[1], [3], [5]]
console.log(arr.map(([x]) => [x, x + 1]))
// [[1, 2], [3, 4], [5, 6]]
console.log(arr.flatMap(([x]) => [x, x + 1]))
// [1, 2, 3, 4, 5, 6]
```

flatMap() 在非数组对象的方法返回数组时特别有用，例如字符串的 split() 方法。来看下面的例子，该例子把一组输入字符串分割为单词，然后把这些单词拼接为一个单词数组：

```js
const arr = ['Lorem ipsum dolor sit amet,', 'consectetur adipiscing elit.']
console.log(arr.flatMap((x) => x.split(/[\W+]/)))
// ["Lorem", "ipsum", "dolor", "sit", "amet", "", "consectetur", "adipiscing","elit", ""]
```

对于上面的例子，可以利用空数组进一步过滤上一次映射后的结果，这也是一个数据处理技巧（虽然可能会有些性能损失）。下面的例子扩展了上面的例子，去掉了空字符串：

```js
const arr = ['Lorem ipsum dolor sit amet,', 'consectetur adipiscing elit.']
console.log(arr.flatMap((x) => x.split(/[\W+]/)).flatMap((x) => x || []))
// ["Lorem", "ipsum", "dolor", "sit", "amet", consectetur", "adipiscing", "elit"]
```
