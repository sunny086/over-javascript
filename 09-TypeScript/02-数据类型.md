# 02-TypeScript 数据类型

## 一 TypeScript 类型的使用

TypeScript 有两种类型使用方式：

- 类型注解（type annotation）：由开发者显式的定义类型
- 类型推断（type interface）：由 TS 自动分析变量类型，分析完成后无法变更

示例：

```ts
// 类型注解
const count: number
// 声明时也可以直接赋值
let age: number = 30

// 类型推断：声明变量之后，再使用时，鼠标移入 num 查看，会显示为 number 类型
let num = 123
```

贴士：在实际开发中，如果一个变量拥有了固定的值，推荐让 TS 自动推导，无需手动设置其变量类型。

变量的类型乍一看有点鸡肋，其作用其实很大程度上体现在函数中，比如如下函数，如果参数没有类型，函数内部的运算就会有隐藏问题，如 undefined 等，且其在一连串的函数调用时会引起连锁错误。一般情况下，我们需要对函数的参数进行类型注解，返回值则可以直接推断出来：

```ts
function total(num1: number, num2: number) {
  return num1 + num2
}

// res 的值类型可以推断出来
let res = total(1, 2)
```

不过要注意 typescript 对类型的严格限定：

```ts
let num1: number
console.log(num1) //声明没有赋值报错

let num2: undefined
console.log(num2) //undefined 类型直接输出不会报错

let num3: number | undefined
console.log(num3) //不会报错

let num: null
num = null //正确
num = 123 //报错，定义一个变量为 null 时，变量的值只能是 null
```

## 二 TypeScript 数据类型汇总

### 2.1 支持 ECMAScript 标准

TypeScript 沿用了 ECMAScript 标准，类型有：

基础类型：number、boolean、string、undefined、null、symbol
引用类型：object（包括 function、array）

此外 TS 还额外支持一些自己独有的类型：

- tuple：元组。
- enum：枚举。
- any/unknown：any 表示任意类型，支持所有类型；unknown 表示未知类型，可以理解为一种类型安全的 any。
- void/never：表示函数没有返回值，void 可以返回 undefined 等值，never 用于函数抛出异常或者进入了无限循环永远没有返回值

### 2.2 数组 array 与 元组 tuple

在 typescript 中可以直接使用 es5 的定义语法：

```ts
let arr1 = [1, 2, 'str'] //ES5 原生数组
```

但是大多数语言的数组内所有元素的类型都是相同的，TS 也支持对数组类元素类型进行限定，一般在 TS 中使用数组采用下列方式：

```ts
let arr2: number[] = [1, 2, 3] //数组元素只能是数字
let arr3: Array<number> = [1, 2, 3] //数组元素只能是数字
```

TS 由于是 JS 的超集，所以也支持在数组中存储不同的数据类型，这种数据类型在大多编程语言中都称呼为元组（Tuple）。TS 中的元组类型表示一个**已知元素数量和类型**的数组，各元素的类型不必相同：

```ts
let tuple1: [number, string] = [1, 'aaa']
let tuple2: [number, string] = [1, 2, 'aaa'] //报错 第二个元素应该是字符串且长度不对
```

贴士：相较于数组，元组的性能更高。

### 2.3 枚举 enum

```ts
enum Flag {
  success = '成功',
  error = '失败',
}
let f: Flag = Flag.success
console.log(f) //成功
```

案例：

```ts
enum Color {
  blue,
  red,
  green = 3,
  '红色',
}
let a: Color = Color.blue
let b: Color = Color.red
let c: Color = Color.green
let d: Color = Color.红色
console.log(a) //输出 0 如果标识符没有赋值，它的值就是下标
console.log(b) //输出 1
console.log(c) //输出 3
console.log(d) //输出 4
```

### 2.4 unknown 与 任意类型 any

在前端开发中通过 getElementById() 获取到的元素是个 object 类型，而 ts 没有该类型，直接赋值就会报错，可以使用 any 类型。

```ts
let num: any = 123
console.log(typeof num)
num = false
console.log(typeof num)
num = 'str'
console.log(typeof num)
```

注意：声明但未赋值的变量也是 any，如下所示：

```ts
let age // any 类型
age = 30 // 此时仍然是 any
```

注意：与 any 相关的数据都会被污染为 any 类型，而关键字 unknown 不会，如下所示：

```ts
// any 类型的 age 将 count 沾染为了 any
let age
age = 30
let count = age + 1 // count 也是 any

// unknown 只影响自己，不会污染其他人
let num: unknown
num = 30 // 此时仍然是 unknown
let result = num + 1 // 这里报错：运算符“+”不能应用于类型“unknown”和“1”
```

综上可以看出，unknown 类型不能直接使用，其本质是**类型安全的 any**，需要先进行类型判断、类型断言才能使用：

```js
let num: unknown
num = 30 // 此时仍然是 unknown

// 类型判断
if (typeof num === 'number') {
    let result = num + 1 // 这里报错
}

// 类型断言：直接告知编译器 num 类型是 number
let result1 :number = num as number + 1 // 断言方式一
let result2 :number = <number>num + 1   // 断言方式二
```

### 2.5 void 类型与 never 类型

void 类型和 never 类型都用来表示函数没有返回值，不过 void 声明的函数中仍然可以返回 undefined 等数据，而 never 则表示该函数绝对不会有返回值，具体解释见下一章节函数部分。

never 类型是任何类型的子类型，可以赋值给任何类型，然而，除了 never 本身之外，没有类型可以赋值给 never 类型（包括 any）。

变量也可以是 never 类型，当它们被永不为真的类型保护所约束时使用。

### 2.6 object 类型

object 类型在 TS 中比较鸡肋，因为对象是需要具体的类型的，比如声明一个 obj 对象：

```ts
let obj: { name: string }

// 报错
// obj = {}

// 正确
obj = {
  name: 'lisi',
}

// 报错：对象的结构必须一致
// obj = {
//     name: 'zhangsan',
//     age: 10,
// }
```

为了解决对象中属性存在一定变数问题，可以在声明对象结构时使用 `?`、`[]`：

```ts
// ? 解决
let obj1: { name: string; age?: number }

obj1 = {
  name: 'zs',
  age: 40,
}

obj1 = {
  name: 'ls',
}

// 如果可选属性过多，可以使用 []
// propName 是笔者自己定义的名称，表示 key，string 代表 key 的类型，any 代表 value 类型
let obj2: { name: string; [propName: string]: any }

obj2 = {
  name: 'zs',
  work: 'teacher',
  age: 10,
}
```

## 三 | 与 &

或符号：

```ts
let obj: { name: string } | { age: number }

obj = { name: 'lisi' }
```

与符号：

```ts
let obj: { name: string } & { age: number }

obj = { name: 'lisi', age: 30 }
```

这 2 个符号经常作用于多个类组成的类型，如：

```js
class A {}
class B {}
let obj: A & B // obj 中需要有 A 与 B 的成员
```

## 四 类型别名

使用 type 关键字可以给类型起个别名：

```ts
type mystr = string

let username: mystr = 'lisi'
```

type 支持或、与操作：

```ts
class A {}
class B {}

type Cus = A & B

let cusInstance: Cus
```
