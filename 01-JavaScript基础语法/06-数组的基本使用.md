# 06-数组的基本使用

本章节主要说明数组的基本使用方式，如：创建、遍历等。在 02-JavaScript 语法进阶的 06.1-容器对象-Array 中更加深入的记录了数组的高阶使用方式。

## 一 数组的基本使用

### 1.1 数组的创建

数组的常见创建方式是：字面量方式、构造函数方式，此外 ES6 新增了 2 个静态方法 `Array.from()`，`Array.of()` 会在 02-JavaScript 语法进阶的 06.1-容器对象-Array 中介绍：

```js
// 直接量方式
let arr0 = [] // 创建一个空数组
let arr1 = [1, 3, 5, 7, 9] // 创建一个包含5个元素的数组
console.log(arr1.length) // 数组长度：5

// 构造函数方式：此时 new 可以省略
let arr2 = new Array()
console.log(arr2.length) // 数组长度：0
console.log(arr2[2]) // undefined

let arr3 = new Array(20) // 初始化一个长度为20的空数组
let arr4 = new Array('zs', 'ls') // 初始化一个拥有2个字符串元素的数组
```

注意：在使用构造函数创建数组时，可以传入数字参数，代表创建数组时，会预先申请数值长度的内存。

### 1.2 数组的空位

数组字面初始化的时候可以使用一串逗号来创建空位（ hole）。 ES6 之前的方法则会忽略这个空位，ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined：

```js
let arr2 = [1, , 3] // 创建了一个元素是空位，值为 undefined
console.log(arr2[2]) // 元素值为：undefined

const options = [, , , , ,] // 创建包含 5 个元素的数组
console.log(options.length) // 5
console.log(options) // [,,,,,]
```

### 1.3 数组的存取

要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如下所示：

```js
let colors = ['red', 'blue', 'green'] // 定义一个字符串数组
alert(colors[0]) // 显示第一项
colors[2] = 'black' // 修改第三项
colors[3] = 'brown' // 添加第四项
```

如果把一个值设置给超过数组最大索引的索引，就像示例中的 `colors[3]`，则数组长度会自动扩展到该索引值加 1（示例中设置的索引 3，所以数组长度变成了 4）。

数组中元素的数量保存在 length 属性中，这个属性始终返回 0 或大于 0 的值。不过要注意的是 **length 属性不是只读的**，通过修改 length 属性，可以从数组末尾删除或添加元素：

```js
let colors = ['red', 'blue', 'green'] // 创建一个包含 3 个字符串的数组
colors.length = 2
console.log(colors[2]) // undefined
```

贴士：数组中最后一个元素的索引始终是 length - 1，如果将 length 设置为大于数组元素数的值，则新添加的元素都将以 undefined 填充。

### 1.4 数组的检测

在只有一个全局执行上下文的情况下，使用 instanceof 可以检测数组：

```js
if (arr instanceof Array) {
  // 操作数组
}
```

如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。 ECMAScript 提供了 Array.isArray()方法用来确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的：

```js
if (Array.isArray(arr)) {
  // 操作数组
}
```

## 二 数组遍历

### 4.1 for 循环遍历

一般使用 for 循环直接遍历数组：

```js
let arr = [1, 2, 5, 8]

let length = arr.length
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}
```

### 4.2 for in 遍历

如果是稀疏数组，推荐使用 for in 进行遍历：

```js
let arr = new Array(10)

arr[1] = 12
arr[3] = 13

for (let item in arr) {
  console.log(item) // 只会输出 1 3
}
```

### 4.3 总结遍历方法

for

### 4.3 forEach 方法

ES5 提供了多个遍历方式：

```js
let arr = [1, 2, 3, 4, 5]
let sum = 0
// 函数参数支持多个
arr.forEach(function (value) {
  // 支持多个参数
  sun += value
})
```

注意：forEach 不支持 break 语句，提前终止需要放在 try 中跑出异常处理：

```js
function foreach(a, f, t) {
  try {
    a.forEach(f, t)
  } catch (e) {
    if (e === foreach.break) {
      return
    } else {
      throw e
    }
  }
}

foreach.break = new Error('StopIteration')
```

## 二 数组的实例方法

### 2.0 数组的实例方法汇总

数组的实例方法有：栈方法（push/pop），队列方法(shift)，排序，操作，搜索，复制，填充，转换，迭代，归并等。本章节主要介绍：栈方法，队列方法，排序方法，操作方法，搜索方法。复制，填充，转换，迭代，归并位于 02-JavaScript 语法进阶的 06.1-容器对象-Array 中。

### 4.3 map() 方法

mpa() 方法将数组的每个元素传递给指定函数，并返回一个数组，包含该函数的返回值：

```js
let arr = [1, 2, 3]
let newArr = arr.map(function (x) {
  return x * x
})
console.log(newArr) //  [ 1, 4, 9 ]
```

### 4.4 filter() 方法

该方法返回的数组元素是调用的数组的一个子集。

```js
let arr = [5, 4, 3, 2, 1]
let newArr = arr.filter(function (x) {
  return x < 3
})
console.log(newArr) //  [ 2, 1]
```

### 4.5 some() 和 every() 方法

some 用法：

```js
let arr = [1, 2, 3, 4, 5]
let isTrue = arr.every(function (x) {
  return x < 10
})
console.log(isTrue) //  true
```

every 与 some 用法相同，但是 every 强调所有元素都必须满足条件，some 只要满足一个元素即可。
其内部原理都是循环数组元素，只不过 every 会循环所有元素，some 只会循环到第一个符合的元素。那么空数组这里，every 会返回 true，some 返回 false。

### 4.6 redue() 和 reduceRight() 方法

该方法使用指定函数将数组元素组合，生成新的值：

```js
let arr = [1, 2, 3, 4, 5]

// 数组元素求和
let sum = arr.reduce(function (x, y) {
  return x + y
}, 0)

// 数组元素求积
let prod = arr.reduce(function (x, y) {
  return x * y
}, 1)

// 求最大值
let max = arr.reduce(function (x, y) {
  return x > y ? x : y
})

console.log(sum) //  15
console.log(prod) //  120
console.log(max) //  5
```

注意：

- 函数的第二个参数可选，是传递给函数的初始值，默认是数组第一个元素的值
- 空数组中，不带初始值参数调用 reduce() 会导致类型错误
- 空数组调用 reduce 并指定初始值，则直接返回初始值
- 只有一个元素的数组调用 reduce 没有指定初始值，则直接返回元素
- reduceRight() 方法是从索引的高到低开始操作。

### 1.3 数组的增删排序

```javascript
push() //数组最末位添加元素
unshift() //数组最前面添加元素
pop() //删除数组最末位元素
shift() //删除数组第一个元素
reverse() //数组反转，示例 arr.reverse().join()
sort() //从小到大依次排序
slice(i, j) //从第 i 个取到第 j 个
splice(m, n) //删除数组中从第 m 个元素开始，取出 n 个组成新数组
indexOf(x, pos)
lastIndexOf(x, pos)
```

### 1.4 数组常见 API

```js
arr1 instanceof arr2 //可以判断数组 A 是否属于数组 B，结果为布尔；
Array.isArray(arr) //H5 新 API，判断是否为数组，结果为布尔。

arr.toString() //数组转字符串，每一项逗号分隔
arr.valueOf() //同上用法，但是返回数组对象本身
//案例：
let arr = [1, 2, 3]
console.log(arr.valueOf()) //[1,2,3]
console.log(arr.toString()) //1,2,3
let arr = [123, 456, 789]
console.log(arr.join('abc')) //123abc456abc789

//数组合并 concat
let arr1 = [123, 456, 789]
let arr2 = ['ab', '张三']
let arr3 = arr1.concat(arr2)
```

### 2.1 栈与队列方法：push()、pop()、shift()、unshift()

数组对象的实例都具备 压栈方法 push() 和 弹栈方法 pop() 用来模仿数据结构栈：

```js
let arr = [2, 3, 5]

// push：末尾追加元素
arr.push(7)
console.log(arr) // [ 2, 3, 5, 7 ]

// pop：末尾删除元素
arr.pop()
console.log(arr) // [ 2, 3, 5 ]
```

数组对象的实例都具备 shift 和 unshift 方法，用来模仿数据结构队列：

```js
// unshift: 首位添加元素
arr.unshift(1)
console.log(arr) // [ 1, 2, 3, 5 ]

// shift：首位删除元素
arr.shift()
console.log(arr) // [ 2, 3, 5 ]
```

### 2.2 数组排序：sort()、reverse()

```js
let arr = [3, 7, 2, 5]

// 排序：
arr.sort() // 默认由小到大排序
console.log(arr) // [ 2, 3, 5, 7 ]

// 反转：
arr.reverse()
console.log(arr) // [ 7, 5, 3, 2 ]
```

sort 方法默认是由小到大排序，其内部会调用每个元素的 toString() 方法，然后得到可比较字符串，最后确定如何排序。但是会遇到下列问题：

```js
let arr = [0, 1, 5, 10, 15]

arr.sort()
console.log(arr) // [ 0, 1, 10, 15, 5 ]
```

这里并未得到用户期望的数据。sort 方法可以接收一个比较函数作为参数，以确保哪个值位于哪个值的前面：

```js
function compare(v1, v2) {
  if (v1 < v2) {
    return -1
  } else if (v1 > v2) {
    return 1
  } else {
    return 0
  }
}

let arr = [0, 1, 5, 10, 15]

arr.sort(compare)
console.log(arr) // [ 0, 1, 5, 10, 15 ]
```

### 2.3 获取索引位置：indexOf()、lastIndexOf()

ECMAScript 5 为数组实例添加了两个位置方法：indexOf() 和 lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf() 方法从数组的开头（位置 0）开始向后查找，lastIndexOf() 方法则从数组的末尾开始向前查找。

这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回 1。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等：

```js
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
console.log(numbers.indexOf(4)) //3
console.log(numbers.lastIndexOf(4)) //5
console.log(numbers.indexOf(4, 4)) //5
console.log(numbers.lastIndexOf(4, 4)) //3
let person = { name: 'Nicholas' }
let people = [{ name: 'Nicholas' }]
let morePeople = [person]
console.log(people.indexOf(person)) //-1
console.log(morePeople.indexOf(person)) //0
```

### 2.4 基于数组创建数组：concat()、slice()

concat() 方法可以基于当前数组中的所有项创建一个新数组。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat() 方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给 concat() 方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾：

```js
let colors = ['red', 'green', 'blue']
let colors2 = colors.concat('yellow', ['black', 'brown'])
console.log(colors) //red,green,blue
console.log(colors2) //red,green,blue,yellow,black,brown
```

slice() 能够基于当前数组中的一或多个项创建一个新数组。slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意，slice() 方法不会影响原始数组。

```js
let colors = ['red', 'green', 'blue', 'yellow', 'purple']
let colors2 = colors.slice(1)
let colors3 = colors.slice(1, 4)
console.log(colors2) //green,blue,yellow,purple
console.log(colors3) //green,blue,yellow
```

splice() 的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种。

- 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2) 会删除数组中的前两项。
- 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,"red","green") 会从当前数组的位置 2 开始插入字符串"red"和"green"。
- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,"red","green") 会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串"red"和"green"。

splice() 方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。

```js
let colors = ['red', 'green', 'blue']
let removed = colors.splice(0, 1) // 删除第一项
console.log(colors) // green,blue
console.log(removed) // red，返回的数组中只包含一项
removed = colors.splice(1, 0, 'yellow', 'orange') // 从位置 1 开始插入两项
console.log(colors) // green,yellow,orange,blue
console.log(removed) // 返回的是一个空数组
removed = colors.splice(1, 1, 'red', 'purple') // 插入两项，删除一项
console.log(colors) // green,red,purple,orange,blue
console.log(removed) // yellow，返回的数组中只包含一项
```

## 二 特殊情况

非负整数也可以作为索引，会进行转换：

```js
arr['100'] = 0 // 索引数组的第 101 个元素
arr[1.0] = 1 // 索引 第 2 个元素
```

但是负数和字符串作为索引时，数值会转换为字符串，作为数组的属性名来使用，而非作为索引使用：

```js
arr[-1.23] = true // 创建一个名为 "-1.23" 的属性
```

事实上数组索引仅仅是对象属性名的一种特殊类型，并非传统语言意义上的索引。js 的数组也没有越界的概念。

## 三 稀疏数组

如果数组是稀疏的，则 length 属性值大于元素的个数。

稀疏数组的三种实现方式：

- 利用 Array() 构造函数创建
- 以大于长度的索引赋值创建
- delete 操作符可以生产稀疏数组

足够稀疏的数组通常在是线上比稠密的数组更慢，但是内存利用率更高，在查找元素时，其时间复杂度与常规对象属性的查找时间一样长。

## 五 多维数组

JS 不支持真正的多维数组，一般使用数组的数组来近似描述：

```js
let arr = new Array(10)
let length = arr.length
for (let i = 0; i < arr.length; i++) {
  arr[i] = new Array(10)
}
```

## 六 类数组

JS 的数组有一些特性，常规对象没有：

- 添加元素时，自动更新 length 属性
- length 重设为较小值，会截断数组
- 从 Array.prototype 中继承了一些有用的方法
- 类属性为 Array

这些特性虽然让数组和对象有了区别，但都不是数组的本质特性。其实可以把一个拥有 length 属性的对象看做类数组，只是类数组的 length 属性不会出现随着元素增删而自动变化：

```js
// 制作一个类数组
let a = {}

for (let i = 0; i < 10; i++) {
  a[i] = i * i
}
a.length = 10
```

类数组不能直接调用 Array.prototype 上的方法，但是由于二者本质都是对象，可以通过 call() 方式调用：

```js
let a = { 0: 'a', 1: 'b', length: 3 }
Array.prototype.join(a, '+') // "a+b+c"
Array.prototype.map.call(a, function (x) {
  // ["A", "B", "C"]
  return x.toUpperCase()
})
```

注意 Firefox 浏览器将上述方法直接定义到了构造函数上，可以如此使用：

```js
let a = { 0: 'a', 1: 'b', length: 3 }
Array.join(a, '+') // "a+b+c"
Array.map.call(a, function (x) {
  // ["A", "B", "C"]
  return x.toUpperCase()
})
```

那么兼容的代码可以这样写：

```js
Array.join =
  Array.join ||
  function (a, sep) {
    return Array.prototype.join.call(a, sep)
  }

Array.map =
  Array.map ||
  function (a, f, thisArg) {
    return Array.prototype.map.call(a, f, thisArg)
  }
```

## 七 作为数组的字符串

字符串是不可变值，如果把字符串当做数组来看待时，是只读的，如 push() 这样的操作在字符串上是无效的。

## 八 语法改进 - 数组新增方法

## 8.1 数组查找

indexOf、lastIndexOf（从后向前），这些是旧版查找：

```js
let arr = [1, 3, 5]
if (arr.indexOf(2) != -1) {
  // 未找到返回 -1，还可以传入第二个参数，指定开始查找的位置（可以是负数）
  console.log('找到了')
}
```

includes 方法，返回值为布尔：

```js
let arr1 = [1, 2, 3]
arr1.inlcludes(2)

// includes 无法查找引用类型
let arr2 = [{ name: 'lisi' }, { age: 13 }]
console.log(arr2.includes({ name: 'lisi' })) // 因为传入的参数是一个新的引用对象了
```

find 与 findIndex 可以解决引用类型查找的问题：

```js
let arr2 = [{ name: 'lisi' }, { age: 13 }]
arr.find((item) => {
  // findIndex 用来查找索引
  return item.name == 'lisi'
})
```

### 8.2 数组遍历

forEach：

```js
let arr = [1, 2, 3]
arr.forEach((item, index, arr) => {})
```

iterator 迭代器：

```js
let arr = [1, 2, 3]

let keys = arr.keys() // 返回索引的可迭代对象
console.log(keys.next()) // { value: 0, done: false }
console.log(keys.next()) // { value: 1, done: false }
console.log(keys.next()) // { value: 2, done: false }

let values = arr.values() // 返回值的可迭代对象
console.log(values.next()) // { value: 1, done: false }
console.log(values.next()) // { value: 2, done: false }
console.log(values.next()) // { value: 3, done: false }
```

every 与 some：

```js
let arr = [1, 2, 3]

// 只要有一次满足，就会返回，适合对数据的统一判断，如判断所有学生成绩是否合格，有一个不合格就会返回 false
let r1 = arr.every((value, index, data) => {
  if (value == 3) {
    return false
  }
})
console.log(r1) // false

// 只有全部数据都迭代一遍，才会返回
let r2 = arr.some((value, index, data) => {
  if (value == 3) {
    return false
  }
})
console.log(r2) // false
```

### 8.3 filter 过滤

```js
let arr = [1, 2, 3]

let newArr = arr.filter((value, index, data) => {
  if (value > 1) {
    return true
  }
})
console.log(newArr) // [ 2, 3 ]
```

### 8.4 map

```js
let arr = [1, 2, 3]

let newArr = arr.map((value, index, data) => {
  if (value > 1) {
    return value
  } else {
    return value + 1
  }
})
console.log(newArr) // [2, 2, 3 ]
```

### 8.5 reduce

```js
let arr = [1, 2, 3]

arr.reduce((pre, after, index, data) => {
  console.log(pre, after)
  return 99
})
```

输出结果为：

```txt
1 2
99 3
```

也可以传递第二个参数，代表第一次循环时，prev 的取值：

```js
let arr = [1, 2, 3]

arr.reduce((pre, after, index, data) => {
  console.log(pre, after)
  return 99
}, 30)
```

输出结果：

```txt
30 1
99 2
99 3
```
